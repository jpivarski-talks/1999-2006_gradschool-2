.TH XSANDBOX 1 "July, 14 2001" "xsandbox"
.SH NAME
xsandbox \- physics-based distraction
.SH SYNOPSIS
.B
xsandbox
[\fIsandbox options...\fR] [\fIGTK options...\fR]
.SH DESCRIPTION
\fBxsandbox\fR renders a sandbox in an X11 window, buffeted by ocean
waves.
.PP
Sand may be added with the left mouse button, removed with the right
mouse button, and pushed around (leveling peaks) with the middle
button.
.PP
Water is simulated with adjustable resolution by a dispersive Laplace
equation, subject to gravity. Water boundary conditions are periodic
at the four edges of the window, and the water height of the bottom
edge is sinusoidally driven to represent the ocean.
.PP
Some parameters can be set at startup time (see \fBSANDBOX
OPTIONS\fR), and others can be changed while \fBxsandbox\fR is running
(see \fBKEYBOARD COMMANDS\fR).
.SH SANDBOX OPTIONS
.TP 8
.B \fI\-geom\fR, \fI\-\-geometry\fR \fB+x+y|wXh[+x+y]\fR (default = 400x300)
This is the standard X11 geometry argument for setting the size and
location of the window. (Setting the window location doesn't yet
work. See \fBKNOWN BUGS\fR)
.TP 8
.B \fI\-nw\fR, \fI\-\-no\-water\fR
Create a window filled with sand but no water. Of course, this is
faster because water is not stopped while the brush is active. It is
also good for tests of new sand features.
.TP 8
.B \fI\-wp\fR, \fI\-\-water\-pixelation\fR \fBint\fR (default = 3)
The integer given after this option describes the width and height of
a single water pixel. Water needs to be drawn with less resolution
than the sand because it would be too slow-moving otherwise. The water
computation time must be inverse-quadratic with pixel size, but the
time necessary to draw the graphics on the screen is constant for
small values above one (then increases!). The speed of the water is
entirely dominated by screen-drawing time for values above four, so no
advantage is gained. If this value is one, the water speed is is about
184+74 ms/iteration, which is much greater than the default
update-time. Therefore, the only sensible options are 2 (40+20
ms/iter), 3 (11+16 ms/iter) and 4 (1+16 ms/iter) (for
computation+drawing times on my computer).
.TP 8
.B \fI\-wc\fR, \fI\-\-water\-coupling\fR \fBfloat\fR (default = 0.45)
This option sets a constant which describes how much the water cares
about differences in height between neighboring pixels. Lower values
would physically correspond to lower gravity or representations of
larger bodies of water (slower waves: the wave speed is proportional
to the square root of the coupling constant). Higher values are more
exciting and dynamic, but if it is set too high, the continuum
approximation breaks down and the water field begins to resemble a
cellular automata with "on" represented by large values of water
height and "off" represented by small ones. With the discretized
Laplace equation, the patterns generated by the automata are usually
just alternating checkerboards, and are slow because every water pixel
needs to be redrawn between iterations. The default value is about as
high as I could safely set this parameter and preserve the continuum
approximation.
.TP 8
.B \fI\-wd\fR, \fI\-\-water\-dissipation\fR \fBfloat\fR (default = 0.05)
This parameter describes the energy loss between iterations, and
represents the friction or viscosity of the water. It needs to be
non-zero to ensure a negative feedback mechanism to bring the water to
an eventual stop\-\- otherwise, it tends to spread itself thin across
the entire window, and the hill isn't enough to stop its
momentum. Higher values less exciting: the default value is as low as
I could set it, keeping the water manageable.
.TP 8
.B \fI\-u\fR, \fI\-\-update\-time\fR \fBint\fR (default = 100)
This is the time in milliseconds between calls to update the water. I
heard in a documentary somewhere a long time back that the animation
limit for the human eye is about a tenth of a second. Shorter times
between updating will be more fluid, but be sure that your computer
can complete a water-updating iteration faster than this. If it can't,
GTK somehow truncates the event queue to keep \fBxsandbox\fR from
crashing, but it is unpleasantly jerky.
.TP 8
.B \fI\-nh\fR, \fI\-\-no\-hill\fR
By default, \fBxsandbox\fR arranges the initial configuration of sand
into a hill which is deepest at the top of the window and shallowest
at the bottom, so that waves flow upward from the generating bottom
edge of the window. With this option, the sand starts out roughly
flat. Water will flow in from both the top and bottom of the window
(due to the periodic boundary conditions) and then lie about in
shallow pools between waves. This option is suggested if you plan to
resize the window while the program is running (see \fBKNOWN BUGS\fR).
.TP 8
.B \fI\-nb\fR, \fI\-\-no\-bumps\fR
This option turns off anisotropies in the initial sand configuration
which are included to make it look more natural. If used with the
\fI\-nh\fR option, the starting sand configuration is completely
flat. (Generating these anisotropies is a significant part of the
startup time.)
.TP 8
.B \fI\-amp\fR, \fI\-\-ocean\-amplitude\fR \fBfloat\fR (default = 1.0)
This controls the amplitude of the ocean waves, in units of the
default value (which was chosen to let the water creep to about the
middle of the window). If sufficiently large, there can be times when
the water runs completely out of the window (when the water height at
the bottom edge wants to be lower than the ground).
.TP 8
.B \fI\-per\fR, \fI\-\-ocean\-period\fR \fBfloat\fR (default = 20.0)
The ocean period is the time in seconds between successive crests of
the ocean wave. Twenty seconds may sound like a long time, but if the
waves are too rapid they will only make ripples on the surface, rather
than completely emptying and filling the window with a large volume of
water.
.SH GTK OPTIONS
.PP
Since \fBxsandbox\fR uses GTK to handle the X11 interface, it has
inherited the standard suite of GTK options. They will be listed but
not described here.
.TP 8
.B \fI\-\-gtk\-module\fR
.TP 8
.B \fI\-\-g\-fatal\-warnings\fR
.TP 8
.B \fI\-\-gtk\-debug\fR
.TP 8
.B \fI\-\-gtk\-no\-debug\fR
.TP 8
.B \fI\-\-gdk\-debug\fR
.TP 8
.B \fI\-\-gdk\-no\-debug\fR
.TP 8
.B \fI\-\-display\fR
.TP 8
.B \fI\-\-sync\fR
.TP 8
.B \fI\-\-no\-xshm\fR
.TP 8
.B \fI\-\-name\fR
.TP 8
.B \fI\-\-class\fR
.SH MOUSE COMMANDS
.PP
While \fBxsandbox\fR is running, the mouse is used as a paintbrush to
add, remove or push sand. The brush acts when a mouse button is
pressed or held down while moving (but not when it is held down and
stationary). Right now, the brush size is fixed in the code, but this
could be raised to the level of a command-line option.
.TP 8
.B \fBLeft Mouse Button \- Add Sand\fR
The sand height is increased in a Gaussian-distributed region around
the cursor.
.TP 8
.B \fBMiddle Mouse Button \- Push Sand\fR
The sand height is flattened to a given level (the level of the sand
where the push started). Any sand that was previously above this level
is pushed by the brush in a clump ahead of the direction of
motion. This is the only of the three brushes which conserves the
quantity of sand. (Although this operation can create very strong
contrasts in sand height (usually seen by the sharp shadow it casts),
the resulting sand distribution is still locally smooth.)
.TP 8
.B \fBRight Mouse Button \- Remove Sand\fR
The sand height is decreased in a Gaussian-distributed region around
the cursor.
.SH KEYBOARD COMMANDS
.PP
If one of the following keys are clicked in the window's focus,
\fBxsandbox\fR will perform the associated action.
.TP 8
.B \fB\fIq\fB or \fIQ\fB \- Quit\fR
\fBxsandbox\fR exits normally.
.TP 8
.B \fB\fIp\fB or \fIP\fB \- Pause\fR
Pause or unpause the water animation.
.TP 8
.B \fB\fIr\fB or \fIR\fB \- Resume\fR
Resume the water animation.
.TP 8
.B \fB\fI>\fB or \fI<\fB \- Rotate Light Source\fR
Increase or decrease the angle of the light source by ten
degrees. Each time it is clicked, the entire window must be redrawn,
so be careful to avoid autorepeating keys.
.TP 8
.B \fB\fIspacebar\fB \- Toggle Contour Lines\fR
Turn on or off the contour lines used to indicate sand elevation. Like
the light source rotation, this command redraws the entire window, so
be careful of autorepeating keys.
.SH PHYSICS IMPLEMENTATION
.PP
The Laplace equation was used to simulate water because nothing else
could make the handling of non-simply connected regions of water both
easy to implement and life-like. The equation is the second-order PDE
normally associated with multi-dimensional waves:
.PP
.EQ C
delim off
{ grad sup 2 } rho ( x vec ) =
{ 1 over { c sup 2 } } { { { partial sup 2 } rho } over { { partial sup 2 } t } }
.EN
.PP
where
.EQ
delim off
rho
.EN
is the height of the water surface and
.EQ
delim off
c
.EN
is the speed of the waves, determined by the coupling constant. To
implement this discretely in a computer it was advantageous to reduce
the order of the equation, since derivatives on a lattice are somewhat
unstable. The second-order PDE can be reduced to two first-order PDEs
by introducing a new field:
.PP
.EQ
delim off
{ j vec }( x vec ) = { c sup 2 } int grad rho ~ dt
~~~ { roman and } ~~~
grad cdot { j vec } = { { partial rho } over { partial t } }
.EN
.PP
where the first equation is a definition of current
.EQ
delim off
j vec
.EN
and the second is known as the continuity equation (because it
requires that fluid can only enter or leave a cell by a current
flowing in or out of it).
.PP
Adding an auxiliary field\-\- a vector field at that\-\- simplifies
the calculation at the expense of storage space. Internally, the
current is modeled by two arrays with the same dimensions as the
water. In the function \fBsand_water_update()\fR, a time-step is
implemented by:
.TP 8
.B \fB1. Requiring continuity
In a loop over water pixels, if the value of a horizontal current
pixel is
.EQ
delim off
x
.EN
, the water pixel to its left will be reduced by
.EQ
delim off
x
.EN
and the water pixel to its right will be increased by
.EQ
delim off
x .
.EN
A second loop is performed over vertical current pixels, where water
is moved up and down. If the current is larger than the amount of
water in the adjacent pixel that it wants to take water from, the
algorithm moves as much water as is available and then sets the
current there to zero, since no more water can be drawn. This
behavior chooses to conserve water at the expense of energy\-\- but
this is physically reasonable since there are a thousand hand-wavy
explanations as to where the energy might be going. One of these
explanations is that in such a case, the energy would distort the
sand slightly, or that heavy sand would be dragged up from the
riverbed when there is the pressure of current with no other fluid to
fill it. If erosion is implemented, this is one place to do it.
.TP 8
.B \fB2. Boundary conditions\fR
Periodic boundary conditions are implemented in the continuity
requirement above, and also in the coupling below. Between the two
implementations, the driving condition is set: the bottom edge of the
window is always required to have a height given by
.EQ
delim off
cos ( 2 pi { t / { roman period } } ) .
.EN
Surface height is modulated, rather than current, because the
continuity condition would completely conserve water for any
variations in current\-\- there would be no way for water to enter or
leave the window, as is expected on a beach near the ocean. Also,
letting the surface height be set by an impassable external source
models an infinite ocean which is completely unaffected by small
modifications to a plot of beach.
.TP 8
.B \fB3. Coupling of water height to current\fR
The current, defined as a time integral of water gradient above, is
implemented by another loop over water pixels. Differences in height
between neighbors are multiplied by the coupling constant (can be
specified with \fI\-wc\fR) and added to the current. The current is
incremented and decremented but never directly set, except in
initialization. For safety, then, its magnitude is reduced in every
time-step by a dissipation factor (can be specified with \fI\-wd\fR),
which corresponds to internal energy loss, such as
viscosity. Mathematically, this can be modeled by inserting a
first-order time derivative in the Laplace equation.
.SH CODE STRUCTURE
.PP
In the later, cleaned-up version of the code, \fBxsandbox\fR is
divided into four modules: \fBxsandbox.cpp\fR, \fBxinterface.cpp\fR,
\fBgraphics.cpp\fR, and \fBsand_water.cpp\fR, each with its associated
header file.
.TP 8
.B \fBxsandbox.cpp\fR
This contains \fBmain()\fR and all argument parsing. Also, all the
default values of arguments are set here\-\- these initializations
override starting values in any other file.
.TP 8
.B \fBxinterface.cpp\fR
Every GTK-specific call is encapsulated here. This is where the
keyboard commands are defined, but the mouse commands are only called
from here. Additional toolbars, if they are added in the future, would
be done in this file using GTK widgets.
.TP 8
.B \fBgraphics.cpp\fR
This handles everything involved in drawing. The RGB \fBbuffer\fR that
mirrors the window content is declared and handled here, as well as
the \fBpixel_draw()\fR function which defines the look of the sand and
water. There is also a \fBsand_speckle\fR field which contains
floating-point numbers, randomly distributed about 1.0, used to vary
the color of the sand enough to look realistic.
.TP 8
.B \fBsand_water.cpp\fR
This is the central bit of the program, where everything important
takes place. Water is updated through \fBsand_water_update()\fR and
the sand distribution is altered by the mouse with the function
\fBsand_brush()\fR. There are six fields here: \fBsand\fR (which has a
width and height one greater than the RGB buffer so that 3-D shadows
are always well-defined), \fBwater\fR, whose width and height are
smaller than \fBsand\fR's by a factor of \fBwater_pixelation\fR,
\fBh_current\fR and \fBv_current\fR, which describe the two components
of the current vector field (at the same resolution as
\fBwater\fR). \fBblocksand\fR is a copy of \fBsand\fR at \fBwater\fR's
resolution (the surface height is \fBwater\fR + \fBblocksand\fR). It
is redrawn in patches whenever the brush action has
finished. \fBwatercopy\fR is a literal copy of the \fBwater\fR
distribution which always lags one iteration behind. It is used only
for comparison to see which pixels on the screen need to be redrawn.
.SH POSSIBLE ENHANCEMENTS
.PP
One thing that could be added to the graphics of this program that
would greatly enhance the realism and feeling of movement is a set of
little white dots, to represent bubbles or foam, which follow the
lines of current in the water. Right now, most of the detail of what
the water is doing is obscured by the fact that it is represented only
by three shades of blue because otherwise keeping ahead of the changes
would be prohibitively expensive in screen-drawing time. But moving
around little specks would only require drawing them in the new
location and covering up the old. To be sufficiently smooth, their
location should be defined by floating point values
.EQ
delim off
x
.EN
and
.EQ
delim off
y,
.EN
only converted to integral pixel locations when sampling the current
or drawing. At each time-step, every bubble can sample the current at
its location (both horizontal and vertical components of current) and
add this vector times a multiplicative constant to its location. The
multiplicative constant would represent the bubble's mass\-\- the
smaller the constant, the larger the mass.
.PP
Melanie suggested that it's just not much fun at the beach without
crabs and starfish and things, so maybe the floating dots idea above
could be expanded to extended objects (graphics and masks taken from a
set of image files, perhaps XPM's). The interesting thing about an
extended object is that it can sample the curl of the current at a
given location: circles around the center of the body of a radius
close to the size of the body can be defined in the current field; the
inner product of the current vector with tangents to this circle can
be calculated and added up for all points in the circle for an
approximation of the curl. Once this is calculated, it can be
multiplied by a constant (inversely proportional to the moment of
inertia of the starfish) and added to the starfish's rotational
velocity. The rotational velocity would just be the number of update
cycles the starfish spends using the same frame in a set of rotating
starfish images.
.PP
One of the motivations of this project was to have a sandbox in which
the water erodes the sand distribution. I became discouraged with this
aspect of the program when I decided that the water resolution needed
to be lower than that of the sand\-\- water would only be able to
erode the sand in pixelated patterns. But supposing that you find a
way to convert a low-resolution action function into a smooth
high-resolution one quickly (some blur operation), an action function
may be defined in terms of the water's characteristics, blurred, and
used to subtract from the \fBsand\fR distribution and add to some new
\fBmud\fR distribution. The \fBmud\fR distribution would have to
satisfy the continuity equation because now that it is waterborne, the
sand is pushed around by the current. Since it describes a density of
sand in the water rather than a height of water, it doesn't affect the
current via a coupling constant like the water does, although it would
be realistic if dissipation is slightly increased in regions where
there is a lot of mud.
.PP
This leaves the action function, the osmotic pressure exerted on the
sand at the bottom of the riverbed, to be defined. Papers on
erosion-simulating software for farmers say that the square of the
intensity of rainfall is a good choice\-\- this is proportional to the
energy, which for us is the square of the current. The action
function, therefore, is
.PP
.EQ
delim off
dislodging_rate( x ) = dislodging_constant times ( { \fBh_current\fR sup 2 } + 
{ \fBv_current\fR sup 2 } ) .
.EN
.PP
This would tend to dig channels where water flow is fastest, which, in
turn, would increase the flow digging the channel, making tree-like
river systems. It might also be good to include in the action function
higher values where the continuity equation has to cheat and draw less
water than the current wanted (see \fBPHYSICS
IMPLEMENTATION\fR). Drawing a little extra sand from these places
would be a good physical explanation as to what happened to the
energy, and it would add sharp edges to riverbed channels, which we
see in nature.
.SH KNOWN BUGS
.PP
The GTK call I use to set the location of the window thinks that the
window pointer I give it is NULL, even though I have already defined
it and have been using it.
.PP
GTK not only determines the window size in terms of the
single "drawing area" it contains, but it also refuses to let the
window be made smaller than this size. Consequently, the user can make
the window larger than the size specified at startup time, but never
smaller. There must be a way around this.
.PP
The way that the sand field responds to new area (by an enlargement of
the window) is very discontinuous, leading to sharp edges in the sand
that cannot be removed with any of the tools (because their action is
linear). Particularly, if the hill option is on (\fI\-nh\fR was NOT
passed), the new area is filled with a hill based on the window's
current dimensions, completely ignoring the content of the old
area. If erosion is implemented (see \fBPOSSIBLE ENHANCEMENTS\fR),
this may become a feature, where the user can watch the water work on
those sharp edges, but currently there is no way to get rid of them.
.SH AUTHOR
Jim McCann <mccann@watson.org>
